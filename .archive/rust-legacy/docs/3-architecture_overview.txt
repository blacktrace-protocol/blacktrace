BlackTrace Architecture Overview - For Claude Code
Purpose: High-level guide to understand the system architecture before implementation

System Architecture: Four-Layer Design
BlackTrace uses a layered architecture where each layer has a specific responsibility and communicates only with adjacent layers. This separation makes the system modular, testable, and maintainable.
┌─────────────────────────────────────────────────────────────┐
│  LAYER 1: USER INTERFACE                                    │
│  Purpose: Human interaction, commands, monitoring           │
│  Technology: Rust CLI                                       │
└─────────────────────────────────────────────────────────────┘
                            ↓ ↑
┌─────────────────────────────────────────────────────────────┐
│  LAYER 2: APPLICATION LOGIC (Off-Chain Coordination)        │
│  Purpose: P2P networking, negotiation, transaction building │
│  Technology: Rust + Commonware/libp2p                       │
└─────────────────────────────────────────────────────────────┘
                            ↓ ↑
┌─────────────────────────────────────────────────────────────┐
│  LAYER 3: COORDINATION LAYER (L2 Contracts)                 │
│  Purpose: Trustless verification, Sybil resistance          │
│  Technology: Cairo smart contracts on Ztarknet              │
└─────────────────────────────────────────────────────────────┘
                            ↓ ↑
┌─────────────────────────────────────────────────────────────┐
│  LAYER 4: SETTLEMENT LAYER (Zcash L1)                       │
│  Purpose: Final atomic value transfer                       │
│  Technology: Zcash Orchard shielded pool + HTLCs            │
└─────────────────────────────────────────────────────────────┘

Layer 1: User Interface
Purpose
The interface between human operators and the BlackTrace system. Handles command parsing, input validation, and output formatting.
Components
1.1 Command Parser

Responsibility: Parse CLI commands and arguments
Inputs: Raw command-line strings from user
Outputs: Validated command objects
Key Functions:

Parse create-order command with amount, stablecoin, price
Parse negotiate command with order ID and price
Parse settle command with order ID
Validate all arguments (positive numbers, valid addresses, etc.)


Error Handling: User-friendly error messages for invalid inputs

1.2 Display Manager

Responsibility: Format and display output to terminal
Inputs: System state, events, errors
Outputs: Formatted terminal output
Key Functions:

Display order book in table format
Show negotiation progress
Display settlement status with progress bar
Show peer list and connection status
Pretty-print errors and warnings


User Experience: Clear, concise, color-coded output

1.3 Configuration Loader

Responsibility: Load and validate configuration files
Inputs: TOML configuration files
Outputs: Configuration objects
Key Functions:

Load network settings (ports, bootstrap nodes)
Load Zcash RPC connection details
Load Ztarknet contract addresses
Validate all configuration values


Defaults: Provide sensible defaults for hackathon testing

Data Flow
User Input → Command Parser → Application Core
                                      ↓
Terminal Output ← Display Manager ← Events/State

Layer 2: Application Logic (Off-Chain Coordination)
Purpose
The brain of BlackTrace. Handles all off-chain coordination including peer discovery, order management, encrypted negotiation, and transaction construction.
Components
2.1 P2P Network Manager
Responsibility: Manage decentralized peer-to-peer network
Sub-Components:
2.1.1 Peer Discovery Engine

Purpose: Find and connect to other BlackTrace nodes
Mechanism: mDNS for local discovery, DHT for global discovery
Inputs: Bootstrap node addresses
Outputs: List of connected peers
Key Functions:

Discover peers on local network automatically
Connect to bootstrap nodes on startup
Maintain peer connection health
Handle peer disconnections and reconnections



2.1.2 Message Router

Purpose: Route messages between peers
Inputs: Messages from local components, messages from network
Outputs: Delivered messages to correct recipients
Key Functions:

Broadcast messages to all peers (for order announcements)
Send direct messages to specific peer (for negotiation)
Handle message acknowledgments
Retry failed message deliveries


Protocols: Gossipsub for broadcast, Request-Response for direct messages

2.1.3 Connection Manager

Purpose: Manage peer connections and network health
Inputs: Peer connection events
Outputs: Connection status, health metrics
Key Functions:

Track connected peers
Detect and handle network partitions
Implement connection limits (max peers)
Calculate peer reputation scores



Data Structures:

Peer list: HashMap<PeerID, PeerInfo>
Message queue: Queue of outgoing messages
Subscription topics: Set of gossipsub topics


2.2 ZK Proof Generator
Responsibility: Generate zero-knowledge proofs for liquidity claims
Sub-Components:
2.2.1 Commitment Scheme (MVP Version)

Purpose: Prove liquidity without revealing amount
Mechanism: Hash-based commitment (upgradeable to ZK-SNARKs)
Inputs:

Actual ZEC balance
Minimum amount to prove
Random salt


Outputs:

Commitment hash
Nullifier (prevents reuse)


Key Functions:

Generate commitment: Hash(amount || salt)
Generate nullifier: Hash(viewing_key || order_id)
Verify commitment matches claimed amount



2.2.2 Proof Verifier

Purpose: Verify other parties' liquidity proofs
Inputs: Proof, commitment, public parameters
Outputs: Boolean (valid/invalid)
Key Functions:

Verify proof structure is correct
Check nullifier hasn't been used before
Validate proof against public parameters
Detect double-spending attempts



2.2.3 Nullifier Registry (Local)

Purpose: Track used nullifiers to prevent reuse
Inputs: Nullifier from new proof
Outputs: Boolean (already used or not)
Storage: In-memory set + persistent database
Key Functions:

Add nullifier when proof verified
Check nullifier before accepting proof
Sync nullifiers with L2 contract (if deployed)



Enhancement Path:

Phase 1: Hash-based commitments (hackathon MVP)
Phase 2: Bulletproofs (if time permits)
Phase 3: Full ZK-SNARKs (post-hackathon)


2.3 Negotiation Engine
Responsibility: Manage private, encrypted price discovery between maker and taker
Sub-Components:
2.3.1 Session Manager

Purpose: Track and manage active negotiation sessions
Inputs: Order IDs, peer IDs
Outputs: Session objects
Key Functions:

Create new negotiation session
Retrieve existing session
Update session state
Clean up completed/cancelled sessions


Storage: HashMap<OrderID, NegotiationSession>

2.3.2 State Machine

Purpose: Enforce negotiation protocol state transitions
States:

DetailsRequested - Taker has requested order details
DetailsRevealed - Maker has shared order details
PriceDiscovery - Multi-round bidding in progress
TermsAgreed - Both parties signed settlement terms
Cancelled - Negotiation terminated


Transitions:

DetailsRequested → DetailsRevealed (maker reveals)
DetailsRevealed → PriceDiscovery (first proposal)
PriceDiscovery → TermsAgreed (both parties accept)
Any state → Cancelled (either party cancels)


Validation: Reject invalid state transitions

2.3.3 Encryption Layer

Purpose: Encrypt negotiation messages end-to-end
Mechanism: ECIES (Elliptic Curve Integrated Encryption Scheme)
Inputs: Plaintext message, recipient's public key
Outputs: Encrypted ciphertext
Key Functions:

Encrypt message for specific peer
Decrypt incoming message with local private key
Key exchange on session creation


Security: Only maker and taker can read messages

2.3.4 Message Handler

Purpose: Process incoming negotiation messages
Message Types:

OrderInterest: Taker requests details
OrderDetails: Maker reveals details
PriceProposal: Either party proposes price
AcceptTerms: Party accepts proposal
CancelNegotiation: Terminate session


Key Functions:

Deserialize and decrypt messages
Route to correct session
Update session state
Generate appropriate response



2.3.5 Proposal Tracker

Purpose: Track negotiation history and proposals
Inputs: Proposals from both parties
Outputs: Proposal history, current best offer
Key Functions:

Record each proposal with timestamp
Track which party made which proposal
Identify when convergence occurs
Provide audit trail



Negotiation Flow:
1. Taker: request_order_details() → Encrypted OrderInterest
2. Maker: reveal_order_details() → Encrypted OrderDetails
3. Taker: propose_price($460) → Encrypted Proposal
4. Maker: counter_propose($455) → Encrypted Proposal
5. Taker: accept_terms() → Encrypted AcceptTerms
6. Both: sign_settlement_terms() → SignedSettlement

2.4 Transaction Builder & Coordinator
Responsibility: Construct Zcash transactions and orchestrate settlement
Sub-Components:
2.4.1 Zcash RPC Client

Purpose: Interface with Zcash full node
Connection: HTTP JSON-RPC to zcashd or zebra
Key Functions:

Get blockchain height
Get unspent notes (UTXOs)
Broadcast transaction
Get transaction confirmations
Monitor mempool


Authentication: Basic auth with username/password

2.4.2 Transaction Builder

Purpose: Construct Zcash shielded transactions
For MVP: Standard shielded transactions (Orchard)
For Enhancement: HTLC-locked transactions
Key Functions:

Build commitment transaction (lock funds)
Build claim transaction (reveal secret)
Build refund transaction (timelock expired)
Sign transactions
Estimate transaction fees



2.4.3 HTLC Manager (Simplified for MVP)

Purpose: Manage Hash Time-Locked Contract logic
Simplified Approach:

Use standard shielded transactions
Store secret in memo field
Implement timelock logic in coordinator (not on-chain)


Full Implementation (Post-Hackathon):

Custom authorization logic in Orchard
On-chain timelock enforcement
Secret reveal in spending proof



2.4.4 Settlement Coordinator

Purpose: Orchestrate atomic swap protocol
Roles: Maker (goes first) and Taker (goes second)
Settlement Phases:
Phase 1: Terms Agreed

Both parties have signed settlement terms
Secret generated by maker
Secret hash shared with taker

Phase 2: Maker Commits

Maker broadcasts transaction locking ZEC
Transaction includes secret hash
Taker monitors for maker's transaction

Phase 3: Taker Commits

Taker verifies maker's transaction
Taker broadcasts transaction locking stablecoin
Maker monitors for taker's transaction

Phase 4: Maker Claims (Reveals Secret)

Maker claims taker's funds
Transaction reveals secret preimage
Network can now see the secret

Phase 5: Taker Claims (Extracts Secret)

Taker extracts secret from maker's claim transaction
Taker claims maker's funds using secret
Settlement complete!



2.4.5 Secret Manager

Purpose: Generate and manage HTLC secrets
Key Functions:

Generate random 32-byte secret
Compute secret hash (Blake2b)
Store secret securely (encrypted)
Reveal secret at appropriate time


Security: Secrets encrypted at rest

2.4.6 Blockchain Monitor

Purpose: Watch blockchain for relevant transactions
Key Functions:

Monitor for counterparty's commitment transaction
Detect secret reveals in claim transactions
Track transaction confirmations
Watch for timelock expiry
Alert on settlement completion


Polling Interval: Every 30 seconds (adjustable)

Atomic Swap Sequence:
T+0:  Terms Agreed (off-chain)
T+1:  Maker commits ZEC (on-chain)
      → Wait 6 confirmations (~60 min)
T+60: Taker verifies, commits USDC (on-chain)
      → Wait 6 confirmations (~60 min)
T+120: Maker claims USDC, reveals secret (on-chain)
       → Wait 1 confirmation (~10 min)
T+130: Taker extracts secret, claims ZEC (on-chain)
       → Settlement complete!
Total: ~2.5 hours

2.5 State Manager
Responsibility: Persist and recover system state
Sub-Components:
2.5.1 Database Layer

Technology: Sled (embedded key-value database)
Purpose: Persist application state to disk
Storage Location: ~/.blacktrace/db/
Key-Value Pairs:

order:{order_id} → OrderState
negotiation:{order_id} → NegotiationSession
settlement:{order_id} → SettlementState
secret:{order_id} → EncryptedSecret
peers → Set<PeerID>



2.5.2 Encryption Layer

Purpose: Encrypt sensitive data at rest
Mechanism: Symmetric encryption (AES-GCM)
Key Derivation: From user passphrase
Encrypted Data:

HTLC secrets
Private keys
Viewing keys



2.5.3 Recovery Manager

Purpose: Restore state after restart
Key Functions:

Load all orders from database
Restore active negotiation sessions
Resume pending settlements
Reconnect to known peers


Error Handling: Gracefully handle corrupted state

2.5.4 State Snapshot

Purpose: Create point-in-time snapshots
Frequency: After every state change
Retention: Keep last 10 snapshots
Use Case: Rollback on corruption


Layer 3: Coordination Layer (Ztarknet L2 Contracts)
Purpose
Provide trustless verification and public attestation without revealing sensitive data. Acts as the "trust anchor" for the off-chain system.
CRITICAL NOTE: This layer is optional for hackathon MVP. Can be mocked client-side if time is short.
Why This Layer Exists
Without L2 Contracts:

No way to prevent Sybil attacks (fake liquidity claims)
Must trust that ZK proofs are valid
No public record of orders
Network relies entirely on peer reputation

With L2 Contracts:

ZK proofs verified on-chain (mathematical guarantee)
Sybil-resistant (expensive to spam fake orders)
Public order registry (decentralized discovery)
Settlement terms anchored on-chain (non-repudiation)

Components
3.1 ZK-Attester Contract
Responsibility: Verify ZK proofs and prevent nullifier reuse
Cairo Contract Functions:
verify_liquidity_proof()

Inputs:

Proof bytes (ZK proof or commitment)
Nullifier (prevents reuse)
Public parameters


Logic:

Check nullifier hasn't been used
Verify proof cryptographically
If valid, mark nullifier as used
Return success/failure


Storage:

verified_nullifiers: HashMap<Nullifier, bool>


Events Emitted:

ProofVerified(nullifier, timestamp)
ProofRejected(nullifier, reason)



is_nullifier_used()

Inputs: Nullifier
Outputs: Boolean (used or not)
Purpose: Check before submitting proof

Security Properties:

Each nullifier can only be used once
Prevents same liquidity being used for multiple orders
Prevents double-counting


3.2 Order Registry Contract
Responsibility: Store attested order commitments publicly
Cairo Contract Functions:
register_order()

Inputs:

Order ID
Encrypted order details (hash)
Minimum amount commitment
Attestation proof (from ZK-Attester)
Expiry timestamp


Logic:

Verify attestation exists
Store order commitment
Increment order counter
Emit OrderRegistered event


Storage:

  struct OrderCommitment {
      order_id: felt,
      maker: felt,  // Account address
      encrypted_details_hash: felt,
      min_amount_commitment: felt,
      attestation_proof: felt,
      timestamp: felt,
      expiry: felt,
      status: felt,  // 0=active, 1=matched, 2=cancelled
  }
  orders: HashMap<OrderID, OrderCommitment>
get_order()

Inputs: Order ID
Outputs: OrderCommitment struct
Purpose: Query order details

cancel_order()

Inputs: Order ID
Authorization: Only maker can cancel
Logic:

Verify caller is maker
Update status to cancelled
Emit OrderCancelled event



get_active_orders()

Inputs: Optional filters (order_type, stablecoin)
Outputs: List of active order IDs
Purpose: Discovery mechanism

Events Emitted:

OrderRegistered(order_id, maker, min_amount, timestamp)
OrderCancelled(order_id, timestamp)


3.3 Negotiation State Registry Contract
Responsibility: Anchor finalized settlement terms
Cairo Contract Functions:
commit_settlement()

Inputs:

Order ID
Settlement terms hash
Maker signature
Taker signature
Maker address
Taker address


Logic:

Verify both signatures
Verify order exists and is active
Store settlement commitment
Mark order as matched
Emit SettlementCommitted event


Storage:

  struct SettlementCommitment {
      order_id: felt,
      terms_hash: felt,
      maker_signature: (felt, felt),
      taker_signature: (felt, felt),
      maker_address: felt,
      taker_address: felt,
      timestamp: felt,
      finalized: felt,
  }
  settlements: HashMap<OrderID, SettlementCommitment>
is_settlement_finalized()

Inputs: Order ID
Outputs: Boolean
Purpose: Check if settlement ready for L1 execution

get_settlement()

Inputs: Order ID
Outputs: SettlementCommitment struct
Purpose: Retrieve settlement details

Events Emitted:

SettlementCommitted(order_id, maker, taker, terms_hash, timestamp)

Why This Matters:

Creates immutable record of agreement
Both parties committed before L1 settlement
Prevents repudiation ("I didn't agree to those terms")
Provides audit trail


Layer 3 Data Flow
Off-Chain (Layer 2) → L2 Contract → Verification Result → Back to Layer 2

Example Flow:
1. ZK Proof Generator creates proof (Layer 2)
2. Submit to ZK-Attester contract (Layer 3)
3. Contract verifies proof cryptographically
4. Contract stores nullifier (prevents reuse)
5. Contract returns verification result
6. Layer 2 uses result to accept/reject order
Layer 3 Interaction Points
From Layer 2 to Layer 3:

Submit ZK proof for verification
Register attested order
Commit finalized settlement terms

From Layer 3 to Layer 2:

Proof verification result
Order registration confirmation
Settlement commitment confirmation
Event notifications (order created, cancelled, matched)

MVP Simplification Strategy
If time is short, mock Layer 3 client-side:

Create mock registry:

rust   struct MockL2Registry {
       verified_nullifiers: HashSet<Nullifier>,
       registered_orders: HashMap<OrderID, OrderCommitment>,
       settlements: HashMap<OrderID, SettlementCommitment>,
   }
```

2. **Implement same interface:**
   - All functions return success immediately
   - Store data in-memory instead of on-chain
   - No gas costs, instant confirmation

3. **Document clearly:**
   - README states "L2 contracts mocked for MVP"
   - Include Cairo contract specifications
   - Explain deployment path

**This allows you to:**
- Complete the hackathon on time
- Demonstrate the architecture
- Deploy contracts later if needed

---

## Layer 4: Settlement Layer (Zcash L1 Protocol)

### Purpose
The final settlement layer where actual value transfer occurs. Provides privacy, security, and atomic guarantees.

**IMPORTANT:** You don't implement Layer 4 - you **use** the existing Zcash protocol via RPC and SDK.

### Components (Zcash Protocol Features You Utilize)

#### 4.1 Orchard Shielded Pool

**What It Is:**
- Zcash's latest shielded transaction protocol
- Launched in 2022 with Zcash 5.0
- Uses Halo2 ZK proofs (no trusted setup needed)

**What It Provides:**
- **Transaction Privacy:** Sender, recipient, and amount are hidden
- **MEV Resistance:** Encrypted mempool prevents front-running
- **Efficient Verification:** Fast proof verification (~milliseconds)

**How BlackTrace Uses It:**
- All settlement transactions use Orchard addresses
- Commitment transactions lock funds in shielded pool
- Claim transactions spend from shielded pool
- Privacy maintained throughout settlement

**SDK Components You Use:**
- `zcash_client_backend` - High-level client functions
- `zcash_primitives` - Core transaction building
- `orchard` - Orchard-specific functions

---

#### 4.2 HTLC (Hash Time-Locked Contract) Logic

**What It Is:**
Cryptographic protocol that enables atomic swaps between two parties without trust.

**HTLC Conditions:**

**Condition 1: Hash Lock (Secret Path)**
```
IF holder provides preimage P where SHA256(P) == secret_hash
THEN holder can claim the funds
```

**Condition 2: Time Lock (Refund Path)**
```
IF current_block_height > timelock_height AND secret not revealed
THEN original sender can reclaim the funds
```

**How It Ensures Atomicity:**
1. Both parties use the **same secret hash**
2. Maker goes first (reveals secret to claim taker's funds)
3. Secret becomes visible on blockchain
4. Taker extracts secret, claims maker's funds
5. Either both succeed or both get refunds

**Implementation Approaches:**

**Approach 1: Simplified (Hackathon MVP)**
- Use standard Orchard transactions
- Store secret in transaction memo field
- Implement timelock logic in coordinator (off-chain)
- Easier to build, demonstrates concept

**Approach 2: Full HTLC (Post-Hackathon)**
- Custom authorization logic in Orchard
- On-chain enforcement of hash lock
- On-chain enforcement of timelock
- More secure, fully trustless

**For the hackathon, Approach 1 is acceptable.**

---

#### 4.3 Transaction Lifecycle

**Understanding Zcash Transaction Flow:**

**Phase 1: Construction**
- Gather input notes (unspent shielded outputs)
- Specify output addresses and amounts
- Add authorization data (signatures, proofs)
- Calculate fees

**Phase 2: Signing**
- Generate spend proofs for each input
- Create output notes
- Sign transaction with spending key
- Verify transaction is valid

**Phase 3: Broadcasting**
- Serialize transaction to hex
- Send to Zcash node via RPC
- Node validates transaction
- Node broadcasts to network

**Phase 4: Mempool**
- Transaction enters mempool (unconfirmed)
- Miners can see transaction exists
- BUT: Amounts/parties remain private (shielded)

**Phase 5: Confirmation**
- Miner includes transaction in block
- Block gets confirmed (~75 seconds)
- Each confirmation increases finality
- Recommend 6 confirmations (~7.5 minutes)

**Phase 6: Finality**
- After 6+ confirmations, settlement is final
- Funds are now spendable by recipient
- Transaction cannot be reversed

---

### How Layer 2 Interacts with Layer 4

**Layer 2 Responsibilities:**
- Decide **when** to settle (after negotiation complete)
- Decide **what** to settle (amounts, addresses)
- Construct the transactions (using Zcash SDK)
- Monitor the blockchain (confirmations, secret reveals)

**Layer 4 Responsibilities:**
- Execute the transactions (Zcash protocol)
- Maintain blockchain consensus (miners/nodes)
- Store transaction data (blockchain)
- Provide RPC interface (zcashd/zebra)

**Connection Point: Zcash RPC**
```
Layer 2 Components           Zcash Node (Layer 4)
─────────────────           ──────────────────────
Transaction Builder ───RPC──> zcashd/zebra
        │                         │
        │ send_raw_transaction    │ validates & broadcasts
        │                         │
Blockchain Monitor  <──RPC─── getblockcount
        │                         │
        │ get_transaction         │ returns tx details
        │                         │
Settlement Coord.   <──RPC─── list_unspent
```

---

## Cross-Layer Data Flow: Complete OTC Trade

### End-to-End Flow Across All Layers

**Step 1: Order Creation**
```
Layer 1 (CLI):
User enters: blacktrace order create --amount 10000 --stablecoin USDC --min-price 450

Layer 2 (App Logic):
→ ZK Proof Generator creates liquidity proof
→ Negotiation Engine creates order object
→ P2P Network broadcasts OrderAnnouncement

Layer 3 (L2 Contracts):
→ ZK-Attester verifies proof
→ Order Registry stores order commitment

Layer 4 (Zcash):
→ (Not involved yet)

Result: Order is public but details are private
```

**Step 2: Order Discovery**
```
Layer 1 (CLI):
User enters: blacktrace order list

Layer 2 (App Logic):
→ P2P Network receives OrderAnnouncement messages
→ Display Manager formats order book

Layer 3 (L2 Contracts):
→ Query Order Registry for active orders

Layer 4 (Zcash):
→ (Not involved yet)

Result: Taker sees available orders
```

**Step 3: Negotiation Request**
```
Layer 1 (CLI):
User enters: blacktrace negotiate request --order-id <ID>

Layer 2 (App Logic):
→ Negotiation Engine creates session
→ Encryption Layer encrypts request
→ P2P Network sends OrderInterest to maker

Layer 3 (L2 Contracts):
→ (Not involved in private negotiation)

Layer 4 (Zcash):
→ (Not involved yet)

Result: Maker receives interest notification
```

**Step 4: Private Price Discovery**
```
Layer 1 (CLI):
Multiple rounds of: blacktrace negotiate propose --price <X>

Layer 2 (App Logic):
→ Negotiation Engine manages state machine
→ Encryption Layer encrypts each proposal
→ P2P Network routes messages privately
→ State Manager persists negotiation history

Layer 3 (L2 Contracts):
→ (Not involved in private negotiation)

Layer 4 (Zcash):
→ (Not involved yet)

Result: Maker and taker agree on price
```

**Step 5: Terms Finalization**
```
Layer 1 (CLI):
User enters: blacktrace negotiate accept --order-id <ID>

Layer 2 (App Logic):
→ Negotiation Engine creates SettlementTerms
→ Both parties sign terms
→ Secret generated and hash computed

Layer 3 (L2 Contracts):
→ Negotiation Registry stores settlement commitment
→ Both signatures verified on-chain

Layer 4 (Zcash):
→ (Not involved yet)

Result: Settlement terms are finalized and attested
```

**Step 6: Maker Commits (L1 Settlement Begins)**
```
Layer 1 (CLI):
User enters: blacktrace settle commit --order-id <ID>

Layer 2 (App Logic):
→ Transaction Builder constructs commitment tx
→ Includes secret hash in transaction
→ Signs with maker's spending key

Layer 3 (L2 Contracts):
→ (Settlement happening on L1, not L2)

Layer 4 (Zcash):
→ Transaction Builder calls send_raw_transaction RPC
→ Zcash node validates transaction
→ Transaction enters mempool
→ Miners include in next block
→ Transaction confirmed after 6 blocks (~7.5 min)

Result: Maker's ZEC is locked with secret hash
```

**Step 7: Taker Verifies and Commits**
```
Layer 1 (CLI):
[Automatic monitoring shows maker's commitment]

Layer 2 (App Logic):
→ Blockchain Monitor detects maker's transaction
→ Settlement Coordinator verifies transaction details
→ Transaction Builder constructs taker's commitment tx
→ Signs with taker's spending key

Layer 3 (L2 Contracts):
→ (Settlement happening on L1, not L2)

Layer 4 (Zcash):
→ Taker's transaction broadcasts to network
→ Transaction confirmed after 6 blocks

Result: Taker's USDC is locked with same secret hash
```

**Step 8: Maker Claims (Reveals Secret)**
```
Layer 1 (CLI):
[Automatic claim after taker's commitment confirmed]

Layer 2 (App Logic):
→ Settlement Coordinator detects taker's commitment
→ Transaction Builder constructs claim transaction
→ Includes secret preimage in transaction
→ Signs with maker's key

Layer 3 (L2 Contracts):
→ (Not involved)

Layer 4 (Zcash):
→ Claim transaction broadcasts
→ Secret is now visible on blockchain
→ Transaction confirmed

Result: Maker receives USDC, secret is revealed
```

**Step 9: Taker Claims (Settlement Complete)**
```
Layer 1 (CLI):
[Automatic claim after secret detected]

Layer 2 (App Logic):
→ Blockchain Monitor extracts secret from maker's claim
→ Settlement Coordinator verifies secret hash matches
→ Transaction Builder constructs taker's claim
→ Uses extracted secret to claim maker's funds

Layer 3 (L2 Contracts):
→ (Not involved)

Layer 4 (Zcash):
→ Taker's claim transaction broadcasts
→ Transaction confirmed
→ Settlement complete!

Result: Taker receives ZEC, atomic swap successful
```

**Step 10: Cleanup**
```
Layer 1 (CLI):
Display: "Settlement complete! ✅"

Layer 2 (App Logic):
→ State Manager updates settlement status to Complete
→ Negotiation Engine archives session
→ P2P Network may broadcast settlement completion (optional)

Layer 3 (L2 Contracts):
→ Could update order status to Matched/Complete
→ Could store settlement proof for audit

Layer 4 (Zcash):
→ Transactions remain in blockchain forever
→ Details remain private (shielded)

Result: Clean state, ready for next trade

Supporting Components (Cross-Layer)
Configuration Management
Purpose: Centralized configuration for all layers
Configuration Files:
config.toml
toml[network]
listen_port = 9000
bootstrap_nodes = ["bootstrap.blacktrace.xyz:9000"]
max_peers = 50

[zcash]
network = "testnet"
rpc_url = "http://localhost:18232"
rpc_user = "zcashrpc"
rpc_password = "secret"

[ztarknet]
rpc_url = "http://localhost:5050"
attester_contract = "0x123..."
registry_contract = "0x456..."

[trading]
default_timelock_blocks = 144  # ~24 hours
min_confirmations = 6
```

**Configuration Loader:**
- Read TOML files
- Validate all values
- Provide defaults
- Environment variable overrides

---

### Logging & Monitoring

**Purpose:** Observability across all layers

**Log Levels:**
- **ERROR:** Critical failures (network partition, settlement failed)
- **WARN:** Recoverable issues (peer disconnected, transaction retry)
- **INFO:** Important events (order created, negotiation complete)
- **DEBUG:** Detailed flow (message sent, state transition)
- **TRACE:** Verbose debugging (every function call)

**What to Log:**

**Layer 1:**
- User commands entered
- Command validation errors

**Layer 2:**
- Peer connections/disconnections
- Messages sent/received
- State transitions
- Transaction broadcasts

**Layer 3:**
- Contract calls
- Verification results
- Gas costs

**Layer 4:**
- RPC calls to Zcash node
- Transaction confirmations
- Block height changes

**Log Aggregation:**
- All logs go to `~/.blacktrace/logs/app.log`
- Rotate daily
- Keep last 7 days

---

### Error Recovery

**Purpose:** Graceful handling of failures at each layer

**Layer 1 Errors:**
- Invalid commands → User-friendly error message
- Solution: Better help text, validation

**Layer 2 Errors:**
- Network partition → Reconnect to bootstrap nodes
- Peer timeout → Mark peer as unresponsive, find alternatives
- Message encryption fails → Retry with new key exchange
- Solution: Automatic retry with exponential backoff

**Layer 3 Errors:**
- Contract call fails → Retry or fallback to mock
- Gas estimation fails → Use higher gas limit
- Solution: Circuit breaker pattern

**Layer 4 Errors:**
- RPC connection lost → Reconnect to Zcash node
- Transaction broadcast fails → Retry with higher fee
- Timelock expires before settlement → Execute refund
- Solution: Monitor and alert, automatic refund

---

## Summary: Component Interaction Map
```
┌─────────────────────────────────────────────────────────────┐
│                    USER (Terminal)                           │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ↓
┌─────────────────────────────────────────────────────────────┐
│  LAYER 1: User Interface                                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │   Command    │  │   Display    │  │  Config      │      │
│  │   Parser     │  │   Manager    │  │  Loader      │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ↓
┌─────────────────────────────────────────────────────────────┐
│  LAYER 2: Application Logic                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  P2P Network │  │  ZK Proof    │  │ Negotiation  │      │
│  │  Manager     │  │  Generator   │  │  Engine      │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│  ┌──────────────┐  ┌──────────────┐                        │
│  │ Transaction  │  │    State     │                        │
│  │  Builder     │  │   Manager    │                        │
│  └──────────────┘  └──────────────┘                        │
└────────┬────────────────────────────┬───────────────────────┘
         │                            │
         ↓                            ↓
┌────────────────────────┐  ┌────────────────────────┐
│  LAYER 3: L2 Contracts │  │ LAYER 4: Zcash L1      │
│  ┌──────────────────┐  │  │ ┌──────────────────┐  │
│  │  ZK-Attester     │  │  │ │  Orchard Pool    │  │
│  └──────────────────┘  │  │ └──────────────────┘  │
│  ┌──────────────────┐  │  │ ┌──────────────────┐  │
│  │  Order Registry  │  │  │ │  HTLC Logic      │  │
│  └──────────────────┘  │  │ └──────────────────┘  │
│  ┌──────────────────┐  │  │ ┌──────────────────┐  │
│  │  Negotiation     │  │  │ │  Blockchain      │  │
│  │  Registry        │  │  │ │  Consensus       │  │
│  └──────────────────┘  │  │ └──────────────────┘  │
└────────────────────────┘  └────────────────────────┘

Key Takeaways for Claude Code
Architectural Principles

Separation of Concerns

Each layer has ONE job
Layers communicate through well-defined interfaces
No layer reaches across boundaries


Progressive Enhancement

Layer 1 (CLI) works with or without Layer 3 (L2 contracts)
Layer 2 can use simplified HTLC or full implementation
Can mock components for faster development


Testability

Each component can be tested in isolation
Integration tests verify layer interactions
End-to-end tests verify complete flow


Baseline Before Integration

Build each component completely
Test thoroughly
Verify it works standalone
THEN integrate with other components



Development Strategy
Week 1:

Days 1-2: Layer 1 (CLI) + Layer 2 foundation (types, errors, P2P)
Days 3-4: Layer 2 core (ZK proofs, negotiation)
Days 5-7: Layer 2 settlement + Layer 4 integration

Week 2:

Days 8-9: Layer 3 (L2 contracts) OR polish if skipping
Days 10-12: Integration, testing, bug fixes
Days 13-14: Demo video, documentation, submission

Success Metrics
Minimum Success (Pass):

2 nodes can discover each other (Layer 2)
Orders can be announced (Layer 2)
Private negotiation works (Layer 2)
Settlement concept demonstrated (Layer 2 + 4)

Good Success (Strong Submission):

Complete E2E flow works
Settlement actually executes on Zcash testnet
Clear, professional demo
Well-documented architecture

Excellent Success (Competitive):

Everything above PLUS:
L2 contracts deployed and working
Full HTLC implementation
Multiple successful test trades
Production-quality code and docs


This architecture overview should give Claude Code a complete mental model of the system before writing any code. Each component's purpose, inputs, outputs, and interactions are now clear.
