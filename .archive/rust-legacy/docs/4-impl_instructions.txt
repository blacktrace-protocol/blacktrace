BlackTrace Protocol - Claude Code Implementation Instructions
Version: 1.0
Purpose: Step-by-step instructions for Claude Code to implement BlackTrace
Approach: Build ‚Üí Test ‚Üí Baseline ‚Üí Move to Next Component

How to Use This Document
Claude Code should:

Read each component's instructions completely before starting
Implement the component according to specifications
Write and run tests to verify functionality
Establish a baseline (working state) before moving to next component
Document what was built and any deviations from the plan

Never proceed to the next component until the current one passes all baseline checks.

Day 0: Project Setup
Instructions for Claude Code
Task: Initialize the BlackTrace project with proper structure and tooling.
Steps:

Create new Rust project:

bash   cargo new blacktrace --bin
   cd blacktrace

Create directory structure:

bash   mkdir -p src/{cli,p2p,crypto,negotiation,settlement,state,config}
   mkdir -p contracts
   mkdir -p tests/{unit,integration}
   mkdir -p docs

Set up initial Cargo.toml with minimal dependencies:

Add tokio for async runtime
Add anyhow and thiserror for error handling
Add tracing for logging
Add serde for serialization


Create initial src/lib.rs that will serve as module root
Set up .gitignore for Rust projects
Create initial README.md with:

Project name and description
Status section (to be updated as components are built)
Build instructions
Testing instructions



Baseline Check:

 cargo build succeeds
 cargo test runs (even if 0 tests)
 Directory structure matches specification
 README exists and is readable

Success Criteria:
Project compiles and is ready for component development.

Phase 1: Core Infrastructure (Days 1-3)
Component 1A: Shared Types & Error Handling
Estimated Time: 4-6 hours
Instructions for Claude Code
Task: Create foundational type system and error handling that all other components will use.
What to Build:

File: src/types.rs

Create these types:

OrderID - Unique identifier for orders (String-based with timestamp)
PeerID - Peer identifier in P2P network (derived from public key hash)
TxID - Zcash transaction ID
Hash - Blake2b 256-bit hash wrapper
OrderType - Enum: Buy or Sell
StablecoinType - Enum: USDC, USDT, DAI
ZcashNetwork - Enum: Mainnet, Testnet
SecretPreimage - 32-byte secret for HTLC


Implementation requirements:

All types must implement: Clone, Debug, Serialize, Deserialize
OrderID should auto-generate with timestamp
SecretPreimage should have a random() constructor
Hash should have a from_bytes() method that uses Blake2b
SecretPreimage should have a hash() method returning Hash




Add dependencies to Cargo.toml:

serde (with derive feature)
blake2
sha2
hex
rand


File: src/error.rs

Create BlackTraceError enum using thiserror
Include error variants for:

Network errors (connection, routing, partition)
Cryptography errors (proof generation/verification, encryption)
Order management (insufficient balance, order not found, nullifier reused)
Negotiation errors (session not found, timeout, counterparty disconnected)
Settlement errors (timelock, secret mismatch, broadcast failure)
State persistence errors
Configuration errors


Create type alias: pub type Result<T> = std::result::Result<T, BlackTraceError>


Update src/lib.rs:

Add pub mod types; and pub mod error;
Re-export common types and Result



Testing Instructions:

File: tests/unit/test_types.rs

Write test: test_order_id_creation() - Verify IDs are unique and properly formatted
Write test: test_peer_id_from_pubkey() - Verify peer IDs are deterministic
Write test: test_hash_consistency() - Verify hashing is deterministic
Write test: test_secret_preimage() - Verify random secrets and hashing
Write test: test_serialization() - Verify serde works for all types


File: tests/unit/test_errors.rs

Write test: test_error_creation() - Verify errors display correctly
Write test: test_result_type() - Verify Result<T> works correctly
Write test: test_error_conversion() - Verify automatic conversion from std::io::Error


Run tests:

bash   cargo test --test unit
Baseline Checklist:

 All 8 tests pass (5 types + 3 errors)
 cargo clippy shows no warnings
 cargo fmt --check shows code is formatted
 All types are serializable/deserializable
 Documentation comments exist for public items

How to Baseline:

Run all tests: cargo test
Check code quality: cargo clippy
Format code: cargo fmt
Update README with:

markdown   ## Status: Types & Errors Complete
   
   ### Components Implemented:
   - ‚úÖ Shared types (OrderID, PeerID, Hash, etc.)
   - ‚úÖ Error handling (BlackTraceError with 20+ variants)
   
   ### Testing:
   - Unit tests: 8/8 passing

Commit: git commit -m "feat: implement shared types and error handling"
Tag: git tag baseline-types-v1

Expected Outcome:
A solid foundation of types and errors that will be used by all subsequent components.

Component 2A: P2P Network Manager
Estimated Time: 8-12 hours
Instructions for Claude Code
Task: Build the P2P networking layer that enables nodes to discover each other and exchange messages.
Technology Decision:
Use libp2p (not Commonware) because it has better documentation and Rust support for a hackathon timeline.
What to Build:

File: src/p2p/network_manager.rs
Create NetworkManager struct with:

local_peer_id: PeerID - This node's identity
swarm: libp2p::Swarm<BlackTraceBehaviour> - libp2p swarm instance
message_tx/rx: mpsc::channel - For async message passing
connected_peers: HashMap<PeerID, PeerId> - Track connected peers

Implement these methods:
a. pub async fn new(listen_port: u16) -> Result<Self>

Generate ED25519 keypair for this node
Create TCP transport with Noise encryption and Yamux multiplexing
Set up Gossipsub for pubsub messaging (topic: "blacktrace-orders")
Set up mDNS for local peer discovery
Create libp2p Swarm
Listen on 0.0.0.0:<listen_port>
Return NetworkManager instance

b. pub fn local_peer_id(&self) -> &PeerID

Return this node's peer ID

c. pub async fn broadcast(&mut self, message: Vec<u8>) -> Result<()>

Publish message to "blacktrace-orders" gossipsub topic
Return Ok if successful

d. pub async fn send_to_peer(&mut self, peer_id: &PeerID, message: Vec<u8>) -> Result<()>

Send direct message to specific peer
Use request-response protocol or direct dial

e. pub async fn poll_events(&mut self) -> Option<NetworkEvent>

Poll libp2p swarm for events
Convert libp2p events to NetworkEvent enum
Return messages received, peer connections/disconnections

f. pub fn connected_peers(&self) -> Vec<PeerID>

Return list of currently connected peers


File: src/p2p/message.rs
Create message types:

rust   pub enum NetworkMessage {
       OrderAnnouncement(OrderAnnouncement),
       OrderInterest(OrderInterest),
       NegotiationMessage(Vec<u8>),  // Encrypted payload
       SettlementCommit(Vec<u8>),    // Settlement data
   }
   
   pub struct OrderAnnouncement {
       pub order_id: OrderID,
       pub order_type: OrderType,
       pub stablecoin: StablecoinType,
       pub encrypted_details: Vec<u8>,  // Encrypted order details
       pub proof_commitment: Hash,      // ZK proof commitment
       pub timestamp: u64,
       pub expiry: u64,
   }
   
   pub struct OrderInterest {
       pub order_id: OrderID,
       pub requester_peer_id: PeerID,
       pub encrypted_request: Vec<u8>,
   }
All messages must be serializable with serde.

File: src/p2p/mod.rs

Export NetworkManager, NetworkMessage, OrderAnnouncement


Add dependencies to Cargo.toml:

toml   libp2p = { version = "0.53", features = ["tcp", "noise", "yamux", "gossipsub", "mdns"] }
   futures = "0.3"
Testing Instructions:

File: tests/integration/test_p2p.rs
Test 1: test_network_creation()

Create NetworkManager on port 9000
Verify local_peer_id is set
Verify swarm is listening
Expected: No panics, manager created successfully

Test 2: test_two_nodes_discovery()

Create Node1 on port 9000
Create Node2 on port 9001
Wait 5 seconds for mDNS discovery
Check Node1.connected_peers() contains Node2
Check Node2.connected_peers() contains Node1
Expected: Both nodes discover each other

Test 3: test_broadcast_message()

Create 3 nodes (ports 9000, 9001, 9002)
Wait for all to discover each other
Node1 broadcasts "test message"
Node2 and Node3 poll for events
Expected: Both Node2 and Node3 receive the message

Test 4: test_direct_message()

Create Node1 and Node2
Wait for discovery
Node1 sends direct message to Node2
Node2 polls and receives message
Expected: Message received only by Node2


Run tests:

bash   cargo test test_p2p -- --test-threads=1
   # Note: --test-threads=1 prevents port conflicts
Baseline Checklist:

 All 4 P2P tests pass
 2 nodes can discover each other via mDNS
 Broadcast messages reach all peers
 Direct messages work peer-to-peer
 No memory leaks (run with cargo test --release)
 Logs show clear peer discovery and message flow

How to Baseline:

Run integration tests: cargo test test_p2p
Run manual test with 3 terminal windows:

bash   # Terminal 1
   cargo run -- node start --port 9000
   
   # Terminal 2
   cargo run -- node start --port 9001
   
   # Terminal 3
   cargo run -- node start --port 9002
Verify all 3 nodes discover each other (check logs)

Update README:

markdown   ## Status: P2P Network Complete
   
   ### Components Implemented:
   - ‚úÖ P2P Network Manager (libp2p-based)
   - ‚úÖ Peer discovery (mDNS)
   - ‚úÖ Message broadcasting (Gossipsub)
   - ‚úÖ Direct messaging
   
   ### Testing:
   - Integration tests: 4/4 passing
   - Manual: 3-node network tested successfully

Commit: git commit -m "feat: implement P2P network manager with libp2p"
Tag: git tag baseline-p2p-v1

Expected Outcome:
Working P2P network where multiple nodes can discover each other and exchange messages.
Troubleshooting Guide for Claude Code:
If tests fail:

Nodes don't discover each other: Increase wait time to 10 seconds, check mDNS is enabled
Port already in use: Use random ports in tests, or clean up previous test instances
Messages not received: Verify gossipsub subscription to correct topic
Timeout errors: Increase async timeouts in tests to 30 seconds


Component 2B: ZK Proof Generator (Simplified)
Estimated Time: 6-8 hours
Instructions for Claude Code
Task: Build ZK proof system for proving liquidity without revealing amounts.
Important Decision:
For the 2-week hackathon, implement a simplified commitment scheme first, then upgrade to full ZK proofs if time permits.
What to Build (Simplified Version):

File: src/crypto/simple_commitment.rs
Create CommitmentGenerator struct:
a. pub fn generate_commitment(amount: u64, salt: &[u8; 32]) -> Hash

Hash the amount + salt using Blake2b
Return Hash(amount || salt)

b. pub fn verify_commitment(commitment: &Hash, amount: u64, salt: &[u8; 32]) -> bool

Regenerate hash from amount + salt
Compare with provided commitment
Return true if match

c. pub fn generate_nullifier(viewing_key: &[u8], order_id: &OrderID) -> Nullifier

Hash(viewing_key || order_id)
Return unique nullifier for this order


File: src/crypto/types.rs

rust   pub struct LiquidityCommitment {
       pub commitment_hash: Hash,
       pub nullifier: Nullifier,
       pub min_amount: u64,  // Public: minimum claimed amount
       pub timestamp: u64,
   }
   
   pub struct Nullifier(pub [u8; 32]);

File: src/crypto/mod.rs

Export CommitmentGenerator and types



Testing Instructions:

File: tests/unit/test_crypto.rs
Test 1: test_commitment_generation()

Generate commitment for amount=10000, random salt
Verify commitment is 32 bytes
Generate again with same inputs
Expected: Same commitment (deterministic)

Test 2: test_commitment_verification()

Generate commitment for amount=5000
Verify with correct amount and salt
Try to verify with wrong amount
Expected: Correct inputs verify, wrong inputs don't

Test 3: test_nullifier_uniqueness()

Generate nullifier for order1 with key1
Generate nullifier for order2 with key1
Generate nullifier for order1 with key2
Expected: All three nullifiers are different

Test 4: test_nullifier_determinism()

Generate nullifier twice with same inputs
Expected: Same nullifier both times


Run tests:

bash   cargo test test_crypto
Baseline Checklist:

 All 4 crypto tests pass
 Commitments are deterministic
 Nullifiers are unique per order+key combination
 No panics or unwraps without proper error handling

How to Baseline:

Run tests: cargo test test_crypto
Verify performance: cargo test test_crypto --release -- --nocapture
Update README:

markdown   ### Components Implemented:
   - ‚úÖ Commitment scheme (hash-based, upgradeable to ZK proofs)
   - ‚úÖ Nullifier generation

Commit: git commit -m "feat: implement commitment scheme for liquidity proofs"
Tag: git tag baseline-crypto-v1

Expected Outcome:
Working commitment system that can prove liquidity claims (simplified version that can be upgraded to ZK proofs later).
Note for Claude Code:
This simplified version is sufficient for the hackathon. If you have extra time at the end, you can upgrade to full Bulletproofs implementation.

Component 2C: Negotiation Engine
Estimated Time: 8-10 hours
Instructions for Claude Code
Task: Build the negotiation engine that manages private, encrypted price discovery between maker and taker.
What to Build:

File: src/negotiation/types.rs
Define negotiation data structures:

rust   pub enum NegotiationState {
       DetailsRequested { timestamp: SystemTime },
       DetailsRevealed { details: OrderDetails, timestamp: SystemTime },
       PriceDiscovery { proposals: Vec<Proposal> },
       TermsAgreed { settlement: SignedSettlement },
       Cancelled { reason: String },
   }
   
   pub struct OrderDetails {
       pub order_id: OrderID,
       pub order_type: OrderType,
       pub amount: u64,
       pub min_price: u64,
       pub max_price: u64,
       pub stablecoin: StablecoinType,
   }
   
   pub struct Proposal {
       pub price: u64,
       pub amount: u64,
       pub proposer: Role,  // Maker or Taker
       pub timestamp: SystemTime,
   }
   
   pub enum Role {
       Maker,
       Taker,
   }
   
   pub struct SettlementTerms {
       pub order_id: OrderID,
       pub zec_amount: u64,
       pub stablecoin_amount: u64,
       pub stablecoin_type: StablecoinType,
       pub maker_address: String,  // Placeholder - will be Zcash address later
       pub taker_address: String,
       pub secret_hash: Hash,
       pub timelock_blocks: u32,
   }
   
   pub struct SignedSettlement {
       pub terms: SettlementTerms,
       pub maker_signature: Vec<u8>,
       pub taker_signature: Vec<u8>,
       pub finalized_at: SystemTime,
   }

File: src/negotiation/session.rs
Create NegotiationSession struct:

rust   pub struct NegotiationSession {
       order_id: OrderID,
       local_role: Role,
       counterparty_peer_id: PeerID,
       state: NegotiationState,
       proposals: Vec<Proposal>,
       created_at: SystemTime,
   }
Implement methods:
a. pub fn new_maker(order_id: OrderID, taker_peer_id: PeerID) -> Self
- Create session as maker
- Initial state: DetailsRequested
b. pub fn new_taker(order_id: OrderID, maker_peer_id: PeerID) -> Self
- Create session as taker
- Initial state: DetailsRequested
c. pub fn add_proposal(&mut self, proposal: Proposal)
- Add proposal to history
- Update state to PriceDiscovery if not already
d. pub fn finalize(&mut self, settlement: SignedSettlement) -> Result<()>
- Verify both signatures present
- Update state to TermsAgreed
e. pub fn cancel(&mut self, reason: String)
- Update state to Cancelled
f. pub fn get_state(&self) -> &NegotiationState
- Return current state

File: src/negotiation/engine.rs
Create NegotiationEngine struct:

rust   pub struct NegotiationEngine {
       active_sessions: HashMap<OrderID, NegotiationSession>,
       local_keypair: (Vec<u8>, Vec<u8>),  // (secret_key, public_key) - simplified
   }
Implement core negotiation methods:
a. pub fn new() -> Self
- Generate local keypair (use ED25519 for simplicity)
- Initialize empty sessions map
b. pub fn request_order_details(&mut self, order_id: OrderID, maker_peer_id: PeerID) -> Result<Vec<u8>>
- Create new taker session
- Create OrderInterest message
- Encrypt with maker's public key (placeholder: just serialize for now)
- Return encrypted message
- Store session in active_sessions
c. pub fn reveal_order_details(&mut self, order_id: &OrderID, details: OrderDetails) -> Result<Vec<u8>>
- Get session, verify we're the maker
- Update state to DetailsRevealed
- Serialize details
- Encrypt for taker (placeholder: just serialize for now)
- Return encrypted message
d. pub fn propose_terms(&mut self, order_id: &OrderID, price: u64, amount: u64) -> Result<Vec<u8>>
- Get session
- Create Proposal
- Add to session
- Serialize and encrypt (placeholder encryption)
- Return message
e. pub fn accept_and_finalize(&mut self, order_id: &OrderID, terms: SettlementTerms) -> Result<SignedSettlement>
- Get session
- Sign the terms (placeholder: just hash for now)
- Create SignedSettlement with both signatures
- Update session state to TermsAgreed
- Return SignedSettlement
f. pub fn handle_message(&mut self, order_id: &OrderID, encrypted_msg: Vec<u8>) -> Result<NegotiationAction>
- Decrypt message (placeholder: just deserialize)
- Determine message type
- Update session state accordingly
- Return action to take (Send, Wait, Finalize, etc.)

File: src/negotiation/mod.rs

Export all public types and NegotiationEngine



Testing Instructions:

File: tests/unit/test_negotiation.rs
Test 1: test_session_creation()

Create maker session
Create taker session
Verify initial states are correct
Expected: Sessions created with DetailsRequested state

Test 2: test_proposal_flow()

Create session
Add 3 proposals with different prices
Verify state transitions to PriceDiscovery
Verify all proposals stored in order
Expected: Proposal history tracks negotiation

Test 3: test_negotiation_cancellation()

Create session
Add proposal
Cancel with reason "taker timeout"
Verify state is Cancelled
Expected: Cancellation works at any stage

Test 4: test_full_negotiation_flow()

Create NegotiationEngine for maker
Create NegotiationEngine for taker
Taker requests order details
Maker reveals details
Taker proposes price
Maker counter-proposes
Taker accepts
Both sign settlement terms
Expected: Full negotiation completes successfully


File: tests/integration/test_negotiation_e2e.rs
Test: test_two_nodes_negotiate()

Start two NetworkManager instances (from Component 2A)
Create NegotiationEngine for each
Node1 (maker) creates order
Node2 (taker) discovers and requests details
Negotiate price via P2P messages
Finalize settlement terms
Expected: Complete negotiation over P2P network



Baseline Checklist:

 All 4 unit tests pass
 Integration test passes (negotiation over P2P)
 State machine transitions correctly
 Sessions can be serialized and persisted
 Cancelled negotiations clean up properly

How to Baseline:

Run unit tests: cargo test test_negotiation
Run integration test: cargo test test_negotiation_e2e
Manual test:

bash   # Terminal 1: Maker
   cargo run -- create-order --amount 10000 --stablecoin USDC --min-price 450
   
   # Terminal 2: Taker  
   cargo run -- list-orders
   cargo run -- negotiate --order-id <ID> --price 460 --amount 10000

Update README:

markdown   ### Components Implemented:
   - ‚úÖ Negotiation Engine (multi-round price discovery)
   - ‚úÖ Session state machine
   - ‚úÖ Encrypted messaging (placeholder, upgradeable)

Commit: git commit -m "feat: implement negotiation engine with state machine"
Tag: git tag baseline-negotiation-v1

Expected Outcome:
Working negotiation system where two parties can discover orders, negotiate prices privately, and finalize settlement terms.
Note for Claude Code:
The encryption is placeholder (just serialization) for now. This is acceptable for hackathon MVP. Real ECIES encryption can be added later if time permits.

Phase 2: Settlement Layer (Days 4-7)
Component 2D: Transaction Builder & Settlement Coordinator
Estimated Time: 12-16 hours
Instructions for Claude Code
Task: Build the Zcash transaction builder and settlement coordinator that executes atomic swaps using HTLCs.
IMPORTANT: This is the most complex component. Start with a simplified version that demonstrates the concept, then enhance if time permits.
Prerequisites:

Zcash testnet node running (zcashd -testnet) OR access to public testnet RPC
Testnet ZEC for testing (get from faucet: https://faucet.testnet.z.cash/)

What to Build (Simplified MVP):

File: src/settlement/zcash_rpc.rs
Create ZcashRPC client:

rust   pub struct ZcashRPC {
       rpc_url: String,
       rpc_user: String,
       rpc_password: String,
       client: reqwest::Client,
   }
Implement methods:
a. pub fn new(rpc_url: String, user: String, password: String) -> Self
- Create HTTP client with basic auth
b. pub async fn get_block_count(&self) -> Result<u64>
- Call getblockcount RPC method
- Return current block height
c. pub async fn send_raw_transaction(&self, tx_hex: String) -> Result<TxID>
- Call sendrawtransaction RPC method
- Return transaction ID
d. pub async fn get_transaction(&self, txid: &str) -> Result<serde_json::Value>
- Call gettransaction RPC method
- Return transaction details
e. pub async fn list_unspent(&self, address: &str) -> Result<Vec<Unspent>>
- Call listunspent for address
- Return list of UTXOs
Add dependency: reqwest = { version = "0.11", features = ["json"] }

File: src/settlement/types.rs
Define settlement types:

rust   pub struct HTLCCommitment {
       pub order_id: OrderID,
       pub amount: u64,
       pub recipient_address: String,
       pub secret_hash: Hash,
       pub timelock_height: u64,
       pub refund_address: String,
   }
   
   pub enum SettlementPhase {
       TermsAgreed,
       MakerCommitted { maker_tx_id: TxID },
       TakerCommitted { maker_tx_id: TxID, taker_tx_id: TxID },
       SecretRevealed { secret: SecretPreimage },
       Completed { maker_claimed: TxID, taker_claimed: TxID },
       Refunded { reason: String },
   }
   
   pub struct SettlementState {
       pub order_id: OrderID,
       pub phase: SettlementPhase,
       pub settlement_terms: SignedSettlement,
       pub created_at: SystemTime,
   }

File: src/settlement/coordinator.rs
Create SettlementCoordinator (Simplified Version):
For the hackathon MVP, implement a simplified version that demonstrates the atomic swap concept without full Orchard HTLC implementation:

rust   pub struct SettlementCoordinator {
       rpc_client: ZcashRPC,
       pending_settlements: HashMap<OrderID, SettlementState>,
       secret_store: HashMap<OrderID, SecretPreimage>,
   }
Implement simplified methods:
a. pub fn new(rpc_client: ZcashRPC) -> Self
- Initialize with RPC client
b. pub async fn initiate_as_maker(&mut self, settlement: SignedSettlement, secret: SecretPreimage) -> Result<TxID>
- For MVP: Create standard shielded transaction (not HTLC)
- Store secret locally
- Broadcast transaction
- Update state to MakerCommitted
- Note: This is simplified - real HTLC comes in enhancement phase
c. pub async fn commit_as_taker(&mut self, order_id: &OrderID, maker_tx_id: TxID) -> Result<TxID>
- Verify maker's transaction exists on-chain
- Create taker's commitment transaction
- Broadcast
- Update state to TakerCommitted
d. pub async fn reveal_secret_and_claim(&mut self, order_id: &OrderID) -> Result<TxID>
- Get stored secret
- Create claim transaction revealing secret
- Broadcast
- Update state to SecretRevealed
e. pub async fn extract_secret_from_tx(&self, tx_id: &TxID) -> Result<SecretPreimage>
- Fetch transaction from blockchain
- Extract secret from transaction data (simplified: from memo field)
- Return secret
f. pub async fn claim_with_secret(&mut self, order_id: &OrderID, secret: SecretPreimage) -> Result<TxID>
- Verify secret hash matches
- Create claim transaction
- Broadcast
- Update state to Completed

File: src/settlement/monitor.rs
Create BlockchainMonitor:

rust   pub struct BlockchainMonitor {
       rpc_client: ZcashRPC,
       watched_txs: HashMap<TxID, OrderID>,
   }
Implement methods:
a. pub fn new(rpc_client: ZcashRPC) -> Self
b. pub fn watch_transaction(&mut self, tx_id: TxID, order_id: OrderID)
- Add to watched transactions
c. pub async fn poll_for_confirmations(&self, tx_id: &TxID) -> Result<u32>
- Get transaction from RPC
- Return confirmation count
d. pub async fn wait_for_confirmation(&self, tx_id: &TxID, min_confirmations: u32) -> Result<()>
- Poll every 30 seconds
- Return when confirmations >= min_confirmations

File: src/settlement/mod.rs

Export all settlement components



Testing Instructions:
CRITICAL: These tests require actual Zcash testnet access and testnet ZEC.

File: tests/integration/test_zcash_rpc.rs
Test 1: test_rpc_connection()

Create ZcashRPC client
Call get_block_count()
Verify height > 0
Expected: Successfully connects to testnet

Test 2: test_transaction_broadcast() (requires testnet ZEC)

Create simple transaction
Broadcast via send_raw_transaction()
Get transaction details
Expected: Transaction appears in mempool


File: tests/integration/test_settlement.rs
Test: test_simplified_atomic_swap() (requires testnet ZEC)

Create SettlementCoordinator for maker
Create SettlementCoordinator for taker
Generate secret
Maker initiates with secret
Taker commits after seeing maker's tx
Maker reveals secret and claims
Taker extracts secret and claims
Expected: Both parties successfully swap funds

Note: This test may take 10-15 minutes due to block confirmations

Baseline Checklist:

 Can connect to Zcash testnet RPC
 Can broadcast transactions to testnet
 Can monitor transaction confirmations
 Simplified atomic swap flow works end-to-end (even if not true HTLC)
 Secret can be revealed and extracted
 Both parties can claim funds

How to Baseline:

Setup testnet access:

bash   # Option 1: Run local zcashd
   zcashd -testnet -daemon
   
   # Option 2: Use public testnet RPC (if available)
   # Configure in config file

Get testnet ZEC:

Visit https://faucet.testnet.z.cash/
Request testnet ZEC to your test address
Wait for confirmation


Run tests:

bash   # RPC tests (fast)
   cargo test test_rpc_connection
   
   # Settlement test (slow - requires confirmations)
   cargo test test_simplified_atomic_swap -- --nocapture
   # Watch output for transaction IDs and confirmation progress

Manual test:

bash   # Terminal 1: Maker
   cargo run -- start-settlement --role maker --amount 1000 --secret <random>
   
   # Wait for maker's transaction to confirm
   
   # Terminal 2: Taker
   cargo run -- start-settlement --role taker --maker-tx <TXID>

Update README:

markdown   ### Components Implemented:
   - ‚úÖ Zcash RPC client
   - ‚úÖ Settlement coordinator (simplified atomic swap)
   - ‚úÖ Blockchain monitor
   - ‚úÖ Testnet integration
   
   ### Known Limitations (MVP):
   - Using standard shielded txs, not full HTLC (can upgrade later)
   - Secret reveal mechanism simplified (memo field)
   - Manual coordination between maker/taker (will automate with P2P)

Commit: git commit -m "feat: implement settlement coordinator with testnet integration"
Tag: git tag baseline-settlement-v1

Expected Outcome:
Working settlement system that can execute atomic swaps on Zcash testnet, even if using simplified approach rather than full HTLC implementation.
Important Notes for Claude Code:
If you get stuck on Orchard HTLC implementation:

The simplified version (standard shielded transactions + memo-based secret sharing) is ACCEPTABLE for hackathon
Document it as "MVP - can be enhanced to full HTLC"
Focus on demonstrating the atomic swap concept
You can always upgrade to proper HTLCs after the hackathon if the judges want to see it

Timelock alternative:

Instead of on-chain timelocks, use time-based logic in coordinator
After 24 hours, allow refund transaction
This demonstrates the concept without complex on-chain scripting

Testing with minimal funds:

Use smallest possible amounts (0.001 ZEC)
Request exactly what you need from faucet
Clean up test transactions to avoid clutter


Phase 3: Layer 3 - Ztarknet Contracts (Days 8-9)
Component 3: Ztarknet L2 Contracts (Optional/Simplified)
Estimated Time: 8-12 hours
Instructions for Claude Code
CRITICAL DECISION POINT:
At this point (Day 8), assess your progress:
If you're on schedule:

Implement simplified Ztarknet contracts
This will strengthen your hackathon submission

If you're behind schedule:

SKIP this component entirely
Mock the contract functionality client-side
Document as "future enhancement"
Focus on polishing the demo

What to Build (Simplified Version):

File: contracts/simple_registry.cairo
Create minimal order registry:

cairo   %lang starknet
   
   from starkware.cairo.common.cairo_builtins import HashBuiltin
   
   @storage_var
   func registered_orders(order_hash: felt) -> (registered: felt) {
   }
   
   @external
   func register_order{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
       order_hash: felt
   ) -> (success: felt) {
       let (already_registered) = registered_orders.read(order_hash);
       if (already_registered == 1) {
           return (success=0);
       }
       
       registered_orders.write(order_hash, 1);
       return (success=1);
   }
   
   @view
   func is_order_registered{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
       order_hash: felt
   ) -> (registered: felt) {
       let (registered) = registered_orders.read(order_hash);
       return (registered=registered);
   }

Testing Cairo Contracts:

bash   # Compile contract
   cairo-compile simple_registry.cairo --output simple_registry_compiled.json
   
   # Test locally (if time permits)
   # Or deploy to Ztarknet testnet

Client-Side Integration:
File: src/ztarknet/client.rs
Create minimal Starknet client to call contracts:

rust   pub struct ZtarknetClient {
       rpc_url: String,
       contract_address: String,
   }
Implement:

register_order(order_hash: Hash) -> Result<bool>
is_order_registered(order_hash: Hash) -> Result<bool>

Baseline Checklist:

 Contract compiles
 Can deploy to testnet (or mock locally)
 Client can call contract functions
 Order registration works

If Skipping This Component:

File: src/ztarknet/mock.rs
Create mock implementation:

rust   pub struct MockRegistry {
       registered_orders: HashSet<Hash>,
   }
   
   impl MockRegistry {
       pub fn register_order(&mut self, order_hash: Hash) -> bool {
           self.registered_orders.insert(order_hash)
       }
       
       pub fn is_registered(&self, order_hash: &Hash) -> bool {
           self.registered_orders.contains(order_hash)
       }
   }

Update README:

markdown   ### Layer 3: Ztarknet Contracts
   - ‚è∏Ô∏è  Mocked for MVP (client-side validation)
   - üìù Contract specs written and ready for deployment
   - üîÑ Can be deployed post-hackathon
Expected Outcome:
Either working L2 contracts or well-documented mocks that demonstrate you understand the architecture even if full implementation wasn't completed in hackathon timeframe.

Phase 4: Integration & Demo (Days 10-14)
Component 4: CLI Interface & End-to-End Integration
Estimated Time: Days 10-12
Instructions for Claude Code
Task: Build the CLI that ties all components together and enables end-to-end OTC trading.
What to Build:

File: src/cli/commands.rs
Implement these commands:
a. Node Management:

blacktrace node start --port 9000 --config ./config.toml
blacktrace node status
blacktrace peers list

b. Order Management:

blacktrace order create --amount 10000 --stablecoin USDC --min-price 450
blacktrace order list --filter sell
blacktrace order cancel --order-id <ID>

c. Negotiation:

blacktrace negotiate request --order-id <ID>
blacktrace negotiate propose --order-id <ID> --price 460 --amount 10000
blacktrace negotiate accept --order-id <ID>

d. Settlement:

blacktrace settle commit --order-id <ID>
blacktrace settle monitor --order-id <ID>
blacktrace settle claim --order-id <ID> --secret <hex>


File: src/cli/display.rs
Create nice terminal output:

rust   pub fn display_order_book(orders: Vec<OrderAnnouncement>) {
       println!("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
       println!("‚ïë      BlackTrace Order Book            ‚ïë");
       println!("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
       for order in orders {
           println!("‚ïë ID: {:<30} ‚ïë", order.order_id.0);
           println!("‚ïë Type: {:<28} ‚ïë", format!("{:?}", order.order_type));
           println!("‚ïü‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï¢");
       }
       println!("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
   }

File: src/main.rs
Create main application that coordinates all components:

rust   #[tokio::main]
   async fn main() -> Result<()> {
       // Initialize logging
       tracing_subscriber::fmt::init();
       
       // Parse CLI args
       let cli = Cli::parse();
       
       match cli.command {
           Commands::Node { .. } => {
               // Start P2P network
               // Initialize all components
               // Run event loop
           }
           Commands::Order { .. } => {
               // Connect to running node
               // Execute order commands
           }
           // ... other commands
       }
   }

File: src/app.rs
Create BlackTraceApp that manages component lifecycle:

rust   pub struct BlackTraceApp {
       network: NetworkManager,
       negotiation_engine: NegotiationEngine,
       settlement_coordinator: SettlementCoordinator,
       state_manager: StateManager,
       config: BlackTraceConfig,
   }
   
   impl BlackTraceApp {
       pub async fn new(config: BlackTraceConfig) -> Result<Self> {
           // Initialize all components
       }
       
       pub async fn run(&mut self) -> Result<()> {
           // Main event loop
           loop {
               tokio::select! {
                   // Handle P2P events
                   Some(event) = self.network.poll_events() => {
                       self.handle_network_event(event).await?;
                   }
                   
                   // Handle user commands
                   Some(cmd) = self.command_rx.recv() => {
                       self.handle_command(cmd).await?;
                   }
                   
                   // Handle settlement monitoring
                   _ = tokio::time::sleep(Duration::from_secs(10)) => {
                       self.check_settlement_status().await?;
                   }
               }
           }
       }
   }
Testing Instructions:

Manual End-to-End Test:
Terminal 1: Maker Node

bash   cargo run -- node start --port 9000 --role maker
   # Wait for startup...
   cargo run -- order create --amount 10000 --stablecoin USDC --min-price 450
   # Note the order ID
Terminal 2: Taker Node
bash   cargo run -- node start --port 9001 --role taker
   # Wait for peer discovery...
   cargo run -- order list
   # Should see maker's order
   cargo run -- negotiate request --order-id <ID>
   cargo run -- negotiate propose --order-id <ID> --price 460 --amount 10000
   # Negotiate back and forth...
   cargo run -- negotiate accept --order-id <ID>
   cargo run -- settle commit --order-id <ID>
Back to Terminal 1: Maker
bash   cargo run -- settle monitor --order-id <ID>
   # Watch for taker's commitment...
   cargo run -- settle claim --order-id <ID>
Back to Terminal 2: Taker
bash   cargo run -- settle claim --order-id <ID> --secret <extracted-from-maker>
   # Settlement complete!

Integration Test:
File: tests/integration/test_e2e.rs

rust   #[tokio::test]
   async fn test_complete_otc_flow() {
       // Start 2 nodes
       // Create order on node1
       // Discover order on node2
       // Negotiate
       // Settle
       // Verify both parties received funds
   }
```

**Baseline Checklist:**
- [ ] All CLI commands work
- [ ] Manual 2-node test completes successfully
- [ ] Order ‚Üí Negotiate ‚Üí Settle flow works end-to-end
- [ ] Logs are clear and helpful
- [ ] Error messages are user-friendly

**How to Baseline:**

1. **Complete manual test (as above)**
2. **Time the full flow:**
   - Order creation: < 1 second
   - Peer discovery: < 10 seconds
   - Negotiation: 1-2 minutes (manual typing)
   - Settlement: 10-20 minutes (blockchain confirmations)
   - **Total: ~20-30 minutes for complete OTC trade**

3. **Check logs show:**
```
   [INFO] Network started on port 9000
   [INFO] Discovered peer: peer_abc123
   [INFO] Order created: order_1699564321000
   [INFO] Received order interest from peer_def456
   [INFO] Negotiation complete: agreed price 460 ZEC/USDC
   [INFO] Maker committed: tx abc123...
   [INFO] Taker committed: tx def456...
   [INFO] Secret revealed, claiming funds...
   [INFO] Settlement complete!

Update README:

markdown   ## Status: MVP Complete! üéâ
   
   ### All Layers Implemented:
   - ‚úÖ Layer 1: CLI interface
   - ‚úÖ Layer 2: P2P network, negotiation, settlement
   - ‚úÖ Layer 3: Registry (mocked)
   - ‚úÖ Layer 4: Zcash L1 integration
   
   ### End-to-End Flow:
   - Order announcement: Working
   - Private negotiation: Working
   - Atomic settlement: Working (simplified HTLC)
   - Time to complete: ~20-30 minutes
   
   ### Demo:
   See `docs/DEMO.md` for step-by-step demo instructions

Commit: git commit -m "feat: complete E2E integration with CLI"
Tag: git tag v0.1.0-hackathon-mvp


Component 5: Demo Preparation & Documentation
Estimated Time: Days 13-14
Instructions for Claude Code
Task: Create demo video, polish documentation, and prepare submission.
What to Build:

File: docs/DEMO.md
Create step-by-step demo guide:

markdown   # BlackTrace Demo Guide
   
   ## Setup (5 minutes)
   
   1. Install dependencies:
```bash
   curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```
   
   2. Clone and build:
```bash
   git clone https://github.com/yourusername/blacktrace
   cd blacktrace
   cargo build --release
```
   
   3. Get testnet ZEC:
   - Visit https://faucet.testnet.z.cash/
   - Request to your test address
   
   ## Demo Flow (20 minutes)
   
   ### Part 1: Start Nodes (2 min)
   [Detailed instructions...]
   
   ### Part 2: Create Order (3 min)
   [Screenshots and commands...]
   
   ### Part 3: Negotiate Price (5 min)
   [Step by step...]
   
   ### Part 4: Execute Settlement (10 min)
   [Monitor confirmations...]

File: docs/ARCHITECTURE.md

markdown   # BlackTrace Architecture
   
   ## Overview
   [High-level diagram]
   
   ## Component Details
   [For each component: purpose, tech stack, interfaces]
   
   ## Data Flow
   [Sequence diagrams for key flows]
   
   ## Design Decisions
   [Why libp2p? Why simplified HTLC? etc.]

File: docs/API.md

markdown   # BlackTrace API Reference
   
   ## CLI Commands
   [All commands with examples]
   
   ## Rust API (for developers)
   [Key public APIs with examples]

Create Demo Video Script:
File: docs/VIDEO_SCRIPT.md

markdown   # Demo Video Script (3 minutes)
   
   ## 0:00-0:30: Problem Statement
   "Institutions can't trade large ZEC positions without information leakage..."
   [Show example of transparent OTC leaking data]
   
   ## 0:30-1:00: Solution Overview
   "BlackTrace provides private OTC coordination..."
   [Show 4-layer architecture diagram]
   
   ## 1:00-2:30: Live Demo
   [Screen recording of complete OTC trade]
   - Start nodes
   - Create order with ZK proof
   - Negotiate privately
   - Execute atomic settlement
   - Show both parties received funds
   
   ## 2:30-3:00: Impact
   "This makes Zcash viable for institutional trading..."
   [Show comparison: traditional vs BlackTrace]

Record Demo Video:
Tools to use:

OBS Studio (screen recording)
Audacity (voiceover)
DaVinci Resolve (editing)

Recording checklist:

 Clean terminal (clear history)
 Zoom text to readable size
 Clear, slow narration
 No errors or typos on screen
 Show actual testnet transactions
 Include GitHub link at end


Polish README.md:

markdown   # BlackTrace Protocol
   
   **Zero-Knowledge OTC Settlement for Institutional Zcash Trading**
   
   [Badges: build status, license, etc.]
   
   ## Quick Start
   [5-line example]
   
   ## The Problem
   [2-3 paragraphs with concrete example]
   
   ## The Solution
   [Architecture diagram]
   [Key differentiators]
   
   ## Demo
   [Link to video]
   [Link to live demo if deployed]
   
   ## Documentation
   - [Architecture](docs/ARCHITECTURE.md)
   - [API Reference](docs/API.md)
   - [Demo Guide](docs/DEMO.md)
   
   ## Built With
   - Rust (networking, crypto, coordination)
   - libp2p (P2P networking)
   - Zcash (settlement layer)
   - Cairo (L2 contracts - optional)
   
   ## Status
   - ‚úÖ MVP complete
   - ‚úÖ Tested on Zcash testnet
   - üîÑ Ready for mainnet (pending audit)
   
   ## Hackathon Submission
   - Event: Zypherpunk Hackathon 2024
   - Category: Private DeFi & Trading
   - Team: [Your name]
   
   ## License
   MIT
Baseline Checklist:

 README is polished and comprehensive
 All documentation files complete
 Demo video recorded and uploaded (YouTube/Vimeo)
 Demo video is 2-3 minutes long
 GitHub repo is public and well-organized
 All tests pass
 Code is formatted (cargo fmt)
 No compiler warnings

How to Baseline:

Run final checks:

bash   cargo test --all
   cargo clippy -- -D warnings
   cargo fmt --check
   cargo build --release

Test demo instructions:

Follow your own DEMO.md on a fresh machine
Verify every command works
Fix any issues


Record demo video:

Practice run 2-3 times
Record final version
Upload to YouTube (unlisted)
Add link to README


Final commit:

bash   git add .
   git commit -m "docs: complete demo video and documentation"
   git tag v1.0.0-hackathon-submission
   git push origin main --tags
Expected Outcome:
Professional, demo-ready project with clear documentation and compelling video showing the complete OTC trading flow.

Submission Checklist
Before Submitting to Hackathon
Code Quality

 All tests pass (cargo test --all)
 No clippy warnings (cargo clippy)
 Code is formatted (cargo fmt)
 No TODO or FIXME comments in main branch
 All public APIs have documentation comments

Documentation

 README.md is complete and compelling
 ARCHITECTURE.md explains design decisions
 API.md documents all public interfaces
 DEMO.md provides clear setup instructions
 All images/diagrams are included in repo

Demo

 Demo video is 2-3 minutes long
 Video shows complete OTC trade on testnet
 Video is uploaded and linked in README
 Video has good audio quality
 Screen is readable in video

Functionality

 2+ nodes can discover each other
 Orders can be announced with ZK proofs (or commitments)
 Private negotiation works peer-to-peer
 Settlement executes on Zcash testnet
 Complete flow takes < 30 minutes
 Logs are clear and informative

Repository

 GitHub repo is public
 Repo has clear description
 License file included (MIT recommended)
 .gitignore excludes build artifacts
 No sensitive keys or credentials committed
 All dependencies listed in Cargo.toml

Submission Form

 Project name: BlackTrace Protocol
 Category: Private DeFi & Trading (or appropriate track)
 GitHub URL included
 Demo video URL included
 Team members listed
 Contact email provided


Contingency Plans
If Behind Schedule
End of Day 7:
If settlement layer not working:

 Submit P2P + Negotiation only
 Mock settlement with placeholders
 Document architecture for full implementation
 Still demonstrates innovation

End of Day 10:
If integration incomplete:

 Submit individual component demos
 Show P2P network separately
 Show negotiation flow separately
 Show settlement concept separately
 Explain how they would integrate

End of Day 12:
If demo not polished:

 Submit working code even if rough
 Write thorough documentation
 Create slides instead of video
 Focus on technical innovation over polish

Minimum Viable Submission
At absolute minimum, to demonstrate the concept:
Must Have:

P2P network (2+ nodes discovering each other)
ZK proof or commitment scheme (showing liquidity)
Basic negotiation (2 parties exchange encrypted messages)
Documentation explaining how settlement would work

This is enough to:

Show you understand the problem
Demonstrate technical innovation
Prove the concept is viable
Win technical merit points


Final Notes for Claude Code
Development Principles

Test Early, Test Often

Write tests as you build, not after
Run tests after every significant change
Don't move to next component until tests pass


Commit Frequently

Commit after each working feature
Use clear commit messages
Tag milestones for easy rollback


Document As You Go

Update README after each component
Add code comments for complex logic
Write down design decisions


Keep It Simple

MVP first, enhancements later
Don't over-engineer
Working simple > broken complex


Ask for Help When Stuck

If blocked for > 2 hours, seek help
Check documentation
Look for similar examples
Consider simpler approach



Success Metrics
Technical Success:

All components baseline successfully
End-to-end flow works
Tests pass
Code is clean

Hackathon Success:

Compelling demo video
Clear value proposition
Working testnet integration
Professional presentation

You've Got This!
Follow the instructions step-by-step, baseline each component, and you'll have a working BlackTrace implementation ready for submission.
Good luck! üöÄ
